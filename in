#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

clearup ()
{
    set +x
    rm -f "$apijson"
    rm -f "$tmp"
    rm -f /tmp/input.json
    rm -f ~/.netrc
}

trap clearup EXIT INT TERM

apijson=$(mktemp -u /tmp/json-XXXXXX)
tmp=$(mktemp -u /tmp/json-XXXXXX)

exec 3>&1
exec 1>&2
jq -M -S . < /dev/stdin > /tmp/input.json

if [ "$(jq -r '.source | has("host")' < /tmp/input.json)" = 'true' ]; then
    host="$(jq -r .source.host < /tmp/input.json)"
else
    echo 'You need to provide the host.'
    exit 1
fi

if [ "$(jq -r '.source | has("user")' < /tmp/input.json)" = 'true' ]; then
    user="$(jq -r .source.user < /tmp/input.json)"
else
    echo 'You need to provide the user.'
    exit 1
fi

if [ "$(jq -r '.source | has("token")' < /tmp/input.json)" = 'true' ]; then
    token="$(jq -r .source.token < /tmp/input.json)"
else
    echo 'You need to provide the token.'
    exit 1
fi

if [ "$(jq -r '.source | has("job")' < /tmp/input.json)" = 'true' ]; then
    job="$(jq -r .source.job < /tmp/input.json)"
else
    echo 'You need to provide the job.'
    exit 1
fi

if [ "$(jq -r '.source | has("port")' < /tmp/input.json)" = 'true' ]; then
    port=":$(jq -r .source.port < /tmp/input.json)"
else
    port=""
fi

if [ "$(jq -r '.source | has("timezone")' < /tmp/input.json)" = 'true' ]; then
    timezone="$(jq -r .source.timezone < /tmp/input.json)"
else
    timezone=UTC
fi

if [ "$(jq -r '.source | has("debug")' < /tmp/input.json)" = 'true' ]; then
    debug="$(jq -r .source.debug < /tmp/input.json)"
else
    debug=""
fi

if [ "$(jq -r '.source | has("protocol")' < /tmp/input.json)" = 'true' ] && [ "$(jq -r .source.protocol < /tmp/input.json)" = "http" ]; then
    protocol="http"
else
    protocol="https"
fi

if [ "$(jq -r '.params | has("timeout")' < /tmp/input.json)" = 'true' ] && [ "$(jq -r .params.timeout < /tmp/input.json)" = "http" ]; then
    timeout=$(jq -r .params.timeout < /tmp/input.json)
else
    timeout=""
fi

cat > ~/.netrc <<ENDLINE
machine $host
 login $user
 password $token
ENDLINE

declare -a IDs=()
declare -A URLs=()
declare -A names=()
declare -A timestamps=()
declare -A durations=()
declare -A results=()

if [ -n "$debug" ]; then
    set -x
fi

readable_timestamp()
{
    if [ "$1" = 'null' ]; then
        echo 'null'
        return
    fi
    TZ="$timezone" date --date="@$(($1/1000))"
}

readable_duration()
{
    if [ "$1" = 'null' ]; then
        echo 'null'
        return
    fi
    if [ "$1" -lt 1000 ]; then
        echo "$1 ms"
        return
    fi
    local T=$(($1/1000))
    local D=$((T/60/60/24))
    local H=$((T/60/60%24))
    local M=$((T/60%60))
    local S=$((T%60))
    if [ $D -eq 1 ]; then
        echo -n "$D day "
    elif [ $D -gt 1 ]; then
        echo -n "$D days "
    fi
    if [ $H -eq 1 ]; then
        echo -n "$H hour "
    elif [ $H -gt 1 ]; then
        echo -n "$H hours "
    fi
    if [ $M -eq 1 ]; then
        echo -n "$M minute "
    elif [ $M -gt 1 ]; then
        echo -n "$M minutes "
    fi
    if [ $S -eq 1 ]; then
        echo "$S second"
    elif [ $S -gt 1 ]; then
        echo "$S seconds"
    fi
}

case "$0" in
    ('/opt/resource/check')
        URL="$protocol://$host$port/$job/api/json"
        curl -nsS "$URL" > "$apijson"
        while read -r url; do
            curl -nsS "${url}api/json" | jq -r > "$tmp"
            id=$(jq -r .id < "$tmp")
            name=$(jq -r .fullDisplayName < "$tmp")
            timestamp=$(jq -r .timestamp < "$tmp")
            duration=$(jq -r .duration < "$tmp")
            result=$(jq -r .result < "$tmp")
            IDs+=("$id")
            URLs[$id]="$url"
            names[$id]=$(echo "$name" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')
            timestamps[$id]=$(readable_timestamp "$timestamp")
            durations[$id]=$(readable_duration "$duration")
            results[$id]="$result"
        done < <(jq -r '.builds | .[].url' < "$apijson")
        ;;
    ('/opt/resource/in')
        URL="$protocol://$host$port/$job/api/json"
        cd "$1"
        expectedResult=()
        expectedMatch=
        url=
        if [ "$(jq -r '.params | has("expectedResult")' < /tmp/input.json)" = 'true' ]; then
            case "$(jq -r '.params.expectedResult | type' < /tmp/input.json)" in
                ('string')
                    expectedResult=("$(jq -r '.params.expectedResult' < /tmp/input.json)")
                    ;;
                ('array')
                    mapfile -t expectedResult < <(jq -r '.params.expectedResult|.[]' < /tmp/input.json | sort)
                    ;;
                (*)
                    echo "Type '$(jq -r '.params.expectedResult | type' < /tmp/input.json)' input is invalid for .params.expectedResult"
                    exit 1
                    ;;
            esac
            duration=0
            until [ -n "$timeout" ] && [[ $duration -ge $timeout ]]; do
                curl -nsS "$URL" > "$apijson"
                while read -r url; do
                    curl -nsS "${url}api/json" | jq -r > "$tmp"
                    result=$(jq -r .result < "$tmp")
                    if [[ "${expectedResult[*]}" =~ $result ]]; then
                        expectedMatch=1
                        break 2
                    elif [ "$result" = 'null' ]; then
                        sleep 5
                        duration=$((duration+5))
                        break
                    else
                        break 2
                    fi
                done < <(jq -r '.builds | .[].url' < "$apijson")
            done
            if [ -n "$url" ] && [ -z "$expectedMatch" ]; then
                echo "$url doesn't have the expected results or timed out ($duration/$timeout)."
                exit 1
            fi
        fi
        if [ -z "$url" ]; then
            curl -nsS "$URL" > "$apijson"
            while read -r url; do
                curl -nsS "${url}api/json" | jq -r > "$tmp"
                break
            done < <(jq -r '.builds | .[].url' < "$apijson")
        fi
        cp "$tmp" api.json
        id=$(jq -r .id < "$tmp")
        name=$(jq -r .fullDisplayName < "$tmp")
        timestamp=$(jq -r .timestamp < "$tmp")
        timestamp=$(readable_timestamp "$timestamp")
        duration=$(jq -r .duration < "$tmp")
        duration=$(readable_duration "$duration")
        result=$(jq -r .result < "$tmp")
        ;;
    ('/opt/resource/out')
        if [ "$(jq -r '.params | has("stringParameters")' < /tmp/input.json)" = 'true' ] || [ "$(jq -r '.params | has("fileParameter")' < /tmp/input.json)" = 'true' ]; then
            URL="$protocol://$host$port/$job/buildWithParameters"
        else
            URL="$protocol://$host$port/$job/build"
        fi

        curl -nsS -X POST -D headers "$URL" > "$apijson"
        [ -n "$debug" ] && jq -r < "$apijson"

        queue=$(grep '^Location: ' headers | awk '{print $2}' | tr -d '\r')
        duration=0
        url=

        until [ -n "$timeout" ] && [[ $duration -ge $timeout ]]; do
            curl -nsS "${queue}api/json" > queue.json
            [ -n "$debug" ] && jq -r < queue.json
            url=$(jq -r '.executable | .url' < queue.json)
            if [ "$url" != 'null' ]; then
                break
            fi
            sleep 5
            duration=$((duration+5))
        done

        if [ -n "$url" ]; then
            curl -nsS "${url}api/json" | jq -r > "$tmp"
            id=$(jq -r .id < "$tmp")
            name=$(jq -r .fullDisplayName < "$tmp")
            timestamp=$(jq -r .timestamp < "$tmp")
            timestamp=$(readable_timestamp "$timestamp")
            duration=$(jq -r .duration < "$tmp")
            duration=$(readable_duration "$duration")
            result=$(jq -r .result < "$tmp")
        else
            echo "No build and timed out ($duration/$timeout)."
            exit 1
        fi
        ;;
esac

case "$0" in
    ('/opt/resource/check')
        mapfile -t reverseIDs < <(sort -u -n <<<"${IDs[*]}")
        json=
        for id in "${reverseIDs[@]}"; do
            if [ -z "$json" ]; then
                json=$(cat <<ENDLINE
[
  {
    "url": "${URLs[$id]}",
    "name": "${names[$id]}",
    "timestamp": "${timestamps[$id]}",
    "duration": "${durations[$id]}",
    "result": "${results[$id]}"
  }
ENDLINE
)
            else
                json=$(cat <<ENDLINE
$json,
  {
    "url": "${URLs[$id]}",
    "name": "${names[$id]}",
    "timestamp": "${timestamps[$id]}",
    "duration": "${durations[$id]}",
    "result": "${results[$id]}"
  }
ENDLINE
)
            fi
        done
        if [ -n "$json" ]; then
            json="$json"']'
        else
            json='[]'
        fi
        ;;
    ('/opt/resource/in'|'/opt/resource/out')
        json=$(cat <<ENDLINE
{
  "version": {
    "url": "${url}",
    "name": "${name}",
    "timestamp": "${timestamp}",
    "duration": "${duration}",
    "result": "${result}"
  },
  "metadata": [
    {"name": "url", "value": "${url}"},
    {"name": "name", "value": "${name}"},
    {"name": "timestamp", "value": "${timestamp}"},
    {"name": "duration", "value": "${duration}"},
    {"name": "result", "value": "${result}"}
  ]
}
ENDLINE
)
        ;;
esac

echo "$json" > "$tmp"
sed -i 's/\t/ /g' "$tmp"
jq -n --slurpfile all "$tmp" '$all[0]' >&3
