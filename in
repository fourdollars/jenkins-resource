#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

clearup ()
{
    set +x
    rm -f "$apijson"
    rm -f "$tmp"
    rm -f /tmp/input.json
    rm -f ~/.netrc
}

trap clearup EXIT INT TERM

apijson=$(mktemp -u /tmp/json-XXXXXX)
tmp=$(mktemp -u /tmp/json-XXXXXX)

exec 3>&1
exec 1>&2
jq -M -S . < /dev/stdin > /tmp/input.json

if [ "$(jq -r '.source | has("host")' < /tmp/input.json)" = 'true' ]; then
    host="$(jq -r .source.host < /tmp/input.json)"
else
    echo 'You need to provide the host.'
    exit 1
fi

if [ "$(jq -r '.source | has("user")' < /tmp/input.json)" = 'true' ]; then
    user="$(jq -r .source.user < /tmp/input.json)"
else
    echo 'You need to provide the user.'
    exit 1
fi

if [ "$(jq -r '.source | has("token")' < /tmp/input.json)" = 'true' ]; then
    token="$(jq -r .source.token < /tmp/input.json)"
else
    echo 'You need to provide the token.'
    exit 1
fi

if [ "$(jq -r '.source | has("job")' < /tmp/input.json)" = 'true' ]; then
    job="$(jq -r .source.job < /tmp/input.json)"
else
    echo 'You need to provide the job.'
    exit 1
fi

if [ "$(jq -r '.source | has("port")' < /tmp/input.json)" = 'true' ]; then
    port=":$(jq -r .source.port < /tmp/input.json)"
else
    port=""
fi

if [ "$(jq -r '.source | has("debug")' < /tmp/input.json)" = 'true' ]; then
    debug="$(jq -r .source.debug < /tmp/input.json)"
else
    debug=""
fi

if [ "$(jq -r '.source | has("protocol")' < /tmp/input.json)" = 'true' ] && [ "$(jq -r .source.protocol < /tmp/input.json)" = "http" ]; then
    protocol="http"
else
    protocol="https"
fi

cat > ~/.netrc <<ENDLINE
machine $host
 login $user
 password $token
ENDLINE

URL="$protocol://$host$port/$job/api/json"

declare -a IDs=()
declare -A URLs=()
declare -A names=()
declare -A timestamps=()
declare -A durations=()
declare -A results=()

if [ -n "$debug" ]; then
    set -x
fi

case "$0" in
    ('/opt/resource/check')
        curl -nsS "$URL" > "$apijson"
        while read -r url; do
            curl -nsS "${url}api/json" | jq -r > "$tmp"
            id=$(jq -r .id < "$tmp")
            name=$(jq -r .fullDisplayName < "$tmp")
            timestamp=$(jq -r .timestamp < "$tmp")
            duration=$(jq -r .duration < "$tmp")
            result=$(jq -r .result < "$tmp")
            IDs+=("$id")
            URLs[$id]="$url"
            names[$id]=$(echo "$name" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')
            timestamps[$id]="$timestamp"
            durations[$id]="$duration"
            results[$id]="$result"
        done < <(jq -r '.builds | .[].url' < "$apijson")
        ;;
    ('/opt/resource/in')
        cd "$1"
        expectedResult=()
        url=
        if [ "$(jq -r '.params | has("expectedResult")' < /tmp/input.json)" = 'true' ]; then
            case "$(jq -r '.params.expectedResult | type' < /tmp/input.json)" in
                ('string')
                    expectedResult=("$(jq -r '.params.expectedResult' < /tmp/input.json)")
                    ;;
                ('array')
                    mapfile -t expectedResult < <(jq -r '.params.expectedResult|.[]' < /tmp/input.json | sort)
                    ;;
                (*)
                    echo "Type '$(jq -r '.params.expectedResult | type' < /tmp/input.json)' input is invalid for .params.expectedResult"
                    exit 1
                    ;;
            esac
            while :; do
                curl -nsS "$URL" > "$apijson"
                while read -r url; do
                    curl -nsS "${url}api/json" | jq -r > "$tmp"
                    result=$(jq -r .result < "$tmp")
                    if [[ "${expectedResult[*]}" =~ $result ]]; then
                        break 2
                    else
                        sleep 10
                        break
                    fi
                done < <(jq -r '.builds | .[].url' < "$apijson")
            done
        fi
        if [ -z "$url" ]; then
            curl -nsS "$URL" > "$apijson"
            while read -r url; do
                curl -nsS "${url}api/json" | jq -r > "$tmp"
                break
            done < <(jq -r '.builds | .[].url' < "$apijson")
        fi
        cp "$tmp" api.json
        id=$(jq -r .id < "$tmp")
        name=$(jq -r .fullDisplayName < "$tmp")
        timestamp=$(jq -r .timestamp < "$tmp")
        duration=$(jq -r .duration < "$tmp")
        result=$(jq -r .result < "$tmp")
        ;;
    ('/opt/resource/out')
        ;;
esac

case "$0" in
    ('/opt/resource/check')
        mapfile -t reverseIDs < <(sort -u -n <<<"${IDs[*]}")
        json=
        for id in "${reverseIDs[@]}"; do
            if [ -z "$json" ]; then
                json=$(cat <<ENDLINE
[
  {
    "url": "${URLs[$id]}",
    "name": "${names[$id]}",
    "timestamp": "${timestamps[$id]}",
    "duration": "${durations[$id]}",
    "result": "${results[$id]}"
  }
ENDLINE
)
            else
                json=$(cat <<ENDLINE
$json,
  {
    "url": "${URLs[$id]}",
    "name": "${names[$id]}",
    "timestamp": "${timestamps[$id]}",
    "duration": "${durations[$id]}",
    "result": "${results[$id]}"
  }
ENDLINE
)
            fi
        done
        if [ -n "$json" ]; then
            json="$json"']'
        else
            json='[]'
        fi
        ;;
    ('/opt/resource/in')
        json=$(cat <<ENDLINE
{
  "version": {
    "url": "${url}",
    "name": "${name}",
    "timestamp": "${timestamp}",
    "duration": "${duration}",
    "result": "${result}"
  },
  "metadata": [
    {"name": "url", "value": "${url}"},
    {"name": "name", "value": "${name}"},
    {"name": "timestamp", "value": "${timestamp}"},
    {"name": "duration", "value": "${duration}"},
    {"name": "result", "value": "${result}"}
  ]
}
ENDLINE
)
        ;;
    ('/opt/resource/out')
        ;;
esac

echo "$json" > "$tmp"
sed -i 's/\t/ /g' "$tmp"
jq -n --slurpfile all "$tmp" '$all[0]' >&3
